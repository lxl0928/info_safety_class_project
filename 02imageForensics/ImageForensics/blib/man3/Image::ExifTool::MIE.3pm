.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Image::ExifTool::MIE 3pm"
.TH Image::ExifTool::MIE 3pm "2016-05-29" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Image::ExifTool::MIE \- Read/write MIE meta information
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module is used by Image::ExifTool
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module contains routines required by Image::ExifTool to read and write
information in \s-1MIE\s0 files.
.SH "WHAT IS MIE?"
.IX Header "WHAT IS MIE?"
\&\s-1MIE\s0 stands for \*(L"Meta Information Encapsulation\*(R".  The \s-1MIE\s0 format is an
extensible, dedicated meta information format which supports storage of
binary as well as textual meta information.  \s-1MIE\s0 can be used to encapsulate
meta information from many sources and bundle it together with any type of
file.
.SS "Features"
.IX Subsection "Features"
Below is very subjective score card comparing the features of a number of
common file and meta information formats, and comparing them to \s-1MIE. \s0 The
following features are rated for each format with a score of 0 to 10:
.PP
.Vb 10
\&  1) Extensible (can incorporate user\-defined information).
\&  2) Meaningful tag ID\*(Aqs (hint to meaning of unknown information).
\&  3) Sequential read/write ability (streamable).
\&  4) Hierarchical information structure.
\&  5) Easy to implement reader/writer/editor.
\&  6) Order of information well defined.
\&  7) Large data lengths supported: >64kB (+5) and >4GB (+5).
\&  8) Localized text strings.
\&  9) Multiple documents in a single file.
\& 10) Compact format doesn\*(Aqt squander disk space or bandwidth.
\& 11) Compressed meta information supported.
\& 12) Relocatable data elements (ie. no fixed offsets).
\& 13) Binary meta information (+7) with variable byte order (+3).
\& 14) Mandatory tags not required (an unnecessary complication).
\& 15) Append information to end of file without editing.
\&
\&                          Feature number                   Total
\&     Format  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15   Score
\&     \-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-
\&     MIE    10 10 10 10 10 10 10 10 10 10 10 10 10 10 10    150
\&     PDF    10 10  0 10  0  0 10  0 10 10 10  0  7 10 10     97
\&     PNG    10 10 10  0  8  0  5 10  0 10 10 10  0 10  0     93
\&     XMP    10 10 10 10  2  0 10 10 10  0  0 10  0 10  0     92
\&     AIFF    0  5 10 10 10  0  5  0  0 10  0 10  7 10  0     77
\&     RIFF    0  5 10 10 10  0  5  0  0 10  0 10  7 10  0     77
\&     JPEG   10  0 10  0 10  0  0  0  0 10  0 10  7 10  0     67
\&     EPS    10 10 10  0  0  0 10  0 10  0  0  5  0 10  0     65
\&     CIFF    0  0  0 10 10  0  5  0  0 10  0 10 10 10  0     65
\&     TIFF    0  0  0 10  5 10  5  0 10 10  0  0 10  0  0     60
\&     EXIF    0  0  0 10  5 10  0  0  0 10  0  0 10  0  0     45
\&     IPTC    0  0 10  0  8  0  0  0  0 10  0 10  7  0  0     45
.Ve
.PP
By design, \s-1MIE\s0 ranks highest by a significant margin.  Other formats with
reasonable scores are \s-1PDF, PNG\s0 and \s-1XMP,\s0 but each has significant weak
points.  What may be surprising is that \s-1TIFF, EXIF\s0 and \s-1IPTC\s0 rank so low.
.PP
As well as scoring high in all these features, the \s-1MIE\s0 format has the unique
ability to encapsulate any other type of file, and provides a non-invasive
method of adding meta information to a file.  The meta information is
logically separated from the original file data, which is extremely
important because meta information is routinely lost when files are edited.
.PP
Also, the \s-1MIE\s0 format supports multiple files by simple concatenation,
enabling all kinds of wonderful features such as linear databases, edit
histories or non-intrusive file updates.  This ability can also be leveraged
to allow MIE-format trailers to be added to some other file types.
.SH "MIE 1.1 FORMAT SPECIFICATION (2007\-01\-21)"
.IX Header "MIE 1.1 FORMAT SPECIFICATION (2007-01-21)"
.SS "File Structure"
.IX Subsection "File Structure"
A \s-1MIE\s0 file consists of a series of \s-1MIE\s0 elements.  A \s-1MIE\s0 element may contain
either data or a group of \s-1MIE\s0 elements, providing a hierarchical format for
storing data.  Each \s-1MIE\s0 element is identified by a human-readable tag name,
and may store data from zero to 2^64\-1 bytes in length.
.SS "File Signature"
.IX Subsection "File Signature"
The first element in the \s-1MIE\s0 file must be an uncompressed \s-1MIE\s0 group element
with a tag name of \*(L"0MIE\*(R".  This restriction allows the first 8 bytes of a
\&\s-1MIE\s0 file to be used to identify a \s-1MIE\s0 format file.  The following table
lists the two possible initial byte sequences for a MIE-format file (the
first for big-endian, and the second for little-endian byte ordering):
.PP
.Vb 1
\&    Byte Number:      0    1    2    3    4    5    6    7
\&
\&    C Characters:     ~ \ex10 \ex04    ?    0    M    I    E
\&        or            ~ \ex18 \ex04    ?    0    M    I    E
\&
\&    Hexadecimal:     7e   10   04    ?   30   4d   49   45
\&        or           7e   18   04    ?   30   4d   49   45
\&
\&    Decimal:        126   16    4    ?   48   77   73   69
\&        or          126   24    4    ?   48   77   73   69
.Ve
.PP
Note that byte 1 may have one of the two possible values (0x10 or 0x18), and
byte 3 may have any value (0x00 to 0xff).
.SS "Element Structure"
.IX Subsection "Element Structure"
.Vb 9
\&    1 byte  SyncByte = 0x7e (decimal 126, character \*(Aq~\*(Aq)
\&    1 byte  FormatCode (see below)
\&    1 byte  TagLength (T)
\&    1 byte  DataLength (gives D if DataLength < 253)
\&    T bytes TagName (T given by TagLength)
\&    2 bytes DataLength2 [exists only if DataLength == 255 (0xff)]
\&    4 bytes DataLength4 [exists only if DataLength == 254 (0xfe)]
\&    8 bytes DataLength8 [exists only if DataLength == 253 (0xfd)]
\&    D bytes DataBlock (D given by DataLength)
.Ve
.PP
The minimum element length is 4 bytes (for a group terminator).  The maximum
DataBlock size is 2^64\-1 bytes.  TagLength and DataLength are unsigned
integers, and the byte ordering for multi-byte DataLength fields is
specified by the containing \s-1MIE\s0 group element.  The SyncByte is byte
aligned, so no padding is added to align on an N\-byte boundary.
.PP
\fIFormatCode\fR
.IX Subsection "FormatCode"
.PP
The format code is a bitmask that defines the format of the data:
.PP
.Vb 5
\&    7654 3210
\&    ++++ \-\-\-\-  FormatType
\&    \-\-\-\- +\-\-\-  TypeModifier
\&    \-\-\-\- \-+\-\-  Compressed
\&    \-\-\-\- \-\-++  FormatSize
.Ve
.IP "FormatType (bitmask 0xf0):" 4
.IX Item "FormatType (bitmask 0xf0):"
.Vb 9
\&    0x00 \- other (or unknown) data
\&    0x10 \- MIE group
\&    0x20 \- text string
\&    0x30 \- list of null\-separated text strings
\&    0x40 \- integer
\&    0x50 \- rational
\&    0x60 \- fixed point
\&    0x70 \- floating point
\&    0x80 \- free space
.Ve
.IP "TypeModifier (bitmask 0x08):" 4
.IX Item "TypeModifier (bitmask 0x08):"
Modifies the meaning of certain FormatTypes (0x00\-0x60):
.Sp
.Vb 7
\&    0x08 \- other data sensitive to MIE group byte order
\&    0x18 \- MIE group with little\-endian byte ordering
\&    0x28 \- UTF encoded text string
\&    0x38 \- UTF encoded text string list
\&    0x48 \- signed integer
\&    0x58 \- signed rational (denominator is always unsigned)
\&    0x68 \- signed fixed\-point
.Ve
.IP "Compressed (bitmask 0x04):" 4
.IX Item "Compressed (bitmask 0x04):"
If this bit is set, the data block is compressed using Zlib deflate.  An
entire \s-1MIE\s0 group may be compressed, with the exception of file-level groups.
.IP "FormatSize (bitmask 0x03):" 4
.IX Item "FormatSize (bitmask 0x03):"
Gives the byte size of each data element:
.Sp
.Vb 4
\&    0x00 \- 8 bits  (1 byte)
\&    0x01 \- 16 bits (2 bytes)
\&    0x02 \- 32 bits (4 bytes)
\&    0x03 \- 64 bits (8 bytes)
.Ve
.Sp
The number of bytes in a single value for this format is given by
2**FormatSize (or 1 << FormatSize).  The number of values is the data length
divided by this number of bytes.  It is an error if the data length is not
an even multiple of the format size in bytes.
.PP
The following is a list of all currently defined \s-1MIE\s0 FormatCode values for
uncompressed data (add 0x04 to each value for compressed data):
.PP
.Vb 10
\&    0x00 \- other data (insensitive to MIE group byte order) (1)
\&    0x01 \- other 16\-bit data (may be byte swapped)
\&    0x02 \- other 32\-bit data (may be byte swapped)
\&    0x03 \- other 64\-bit data (may be byte swapped)
\&    0x08 \- other data (sensitive to MIE group byte order) (1)
\&    0x10 \- MIE group with big\-endian values (1)
\&    0x18 \- MIE group with little\-endian values (1)
\&    0x20 \- ASCII (ISO 8859\-1) string (2,3)
\&    0x28 \- UTF\-8 string (2,3,4)
\&    0x29 \- UTF\-16 string (2,3,4)
\&    0x2a \- UTF\-32 string (2,3,4)
\&    0x30 \- ASCII (ISO 8859\-1) string list (3,5)
\&    0x38 \- UTF\-8 string list (3,4,5)
\&    0x39 \- UTF\-16 string list (3,4,5)
\&    0x3a \- UTF\-32 string list (3,4,5)
\&    0x40 \- unsigned 8\-bit integer
\&    0x41 \- unsigned 16\-bit integer
\&    0x42 \- unsigned 32\-bit integer
\&    0x43 \- unsigned 64\-bit integer (6)
\&    0x48 \- signed 8\-bit integer
\&    0x49 \- signed 16\-bit integer
\&    0x4a \- signed 32\-bit integer
\&    0x4b \- signed 64\-bit integer (6)
\&    0x52 \- unsigned 32\-bit rational (16\-bit numerator then denominator) (7)
\&    0x53 \- unsigned 64\-bit rational (32\-bit numerator then denominator) (7)
\&    0x5a \- signed 32\-bit rational (denominator is unsigned) (7)
\&    0x5b \- signed 64\-bit rational (denominator is unsigned) (7)
\&    0x61 \- unsigned 16\-bit fixed\-point (high 8 bits is integer part) (8)
\&    0x62 \- unsigned 32\-bit fixed\-point (high 16 bits is integer part) (8)
\&    0x69 \- signed 16\-bit fixed\-point (high 8 bits is signed integer) (8)
\&    0x6a \- signed 32\-bit fixed\-point (high 16 bits is signed integer) (8)
\&    0x72 \- 32\-bit IEEE float (not recommended for portability reasons)
\&    0x73 \- 64\-bit IEEE double (not recommended for portability reasons) (6)
\&    0x80 \- free space (value data does not contain useful information)
.Ve
.PP
Notes:
.IP "1." 4
The byte ordering specified by the \s-1MIE\s0 group TypeModifier applies to the \s-1MIE\s0
group element as well as all elements within the group.  Data for all
FormatCodes except 0x08 (other data, sensitive to byte order) may be
transferred between \s-1MIE\s0 groups with different byte order by byte swapping
the uncompressed data according to the specified data format.  The following
list illustrates the byte-swapping pattern, based on FormatSize, for all
format types except rational (FormatType 0x50).
.Sp
.Vb 6
\&      FormatSize              Change in Byte Sequence
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-      \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    0x00 (8 bits)       0 1 2 3 4 5 6 7 \-\-> 0 1 2 3 4 5 6 7 (no change)
\&    0x01 (16 bits)      0 1 2 3 4 5 6 7 \-\-> 1 0 3 2 5 4 7 6
\&    0x02 (32 bits)      0 1 2 3 4 5 6 7 \-\-> 3 2 1 0 7 6 5 4
\&    0x03 (64 bits)      0 1 2 3 4 5 6 7 \-\-> 7 6 5 4 3 2 1 0
.Ve
.Sp
Rational values consist of two integers, so they are swapped as the next
lower FormatSize.  For example, a 32\-bit rational (FormatSize 0x02, and
FormatCode 0x52 or 0x5a) is swapped as two 16\-bit values (ie. as if it had
FormatSize 0x01).
.IP "2." 4
The TagName of a string element may have an 6\-character suffix to indicate a
specific locale. (eg. \*(L"Title\-en_US\*(R", or \*(L"Keywords\-de_DE\*(R").
.IP "3." 4
Text strings are not normally null terminated, however they may be padded
with one or more null characters to the end of the data block to allow
strings to be edited within fixed-length data blocks.  Newlines in the text
are indicated by a single \s-1LF \s0(0x0a) character.
.IP "4." 4
\&\s-1UTF\s0 strings must not begin with a byte order mark (\s-1BOM\s0) since the byte order
and byte size are specified by the \s-1MIE\s0 format.  If a \s-1BOM\s0 is found, it should
be treated as a zero-width non-breaking space.
.IP "5." 4
A list of text strings separated by null characters.  These lists must not
be null padded or null terminated, since this would be interpreted as
additional zero-length strings.  For \s-1ASCII\s0 and \s-1UTF\-8\s0 strings, the null
character is a single zero (0x00) byte.  For \s-1UTF\-16\s0 or \s-1UTF\-32\s0 strings, the
null character is 2 or 4 zero bytes respectively.
.IP "6." 4
64\-bit integers and doubles are subject to the specified byte ordering for
both 32\-bit words and bytes within these words.  For instance, the high
order byte is always the first byte if big-endian, and the eighth byte if
little-endian.  This means that some swapping is always necessary for these
values on systems where the byte order differs from the word order (eg. some
\&\s-1ARM\s0 systems), regardless of the endian-ness of the stored values.
.IP "7." 4
Rational values are treated as two separate integers.  The numerator always
comes first regardless of the byte ordering.  In a signed rational value,
only the numerator is signed.  The denominator of all rational values is
unsigned (eg. a signed 64\-bit rational of 0x80000000/0x80000000 evaluates to
\&\-1, not +1).
.IP "8." 4
32\-bit fixed point values are converted to floating point by treating them
as an integer and dividing by an appropriate value.  eg)
.Sp
.Vb 2
\&    16\-bit fixed value = 16\-bit integer value / 256.0
\&    32\-bit fixed value = 32\-bit integer value / 65536.0
.Ve
.PP
\fITagLength\fR
.IX Subsection "TagLength"
.PP
Gives the length of the TagName string.  Any value between 0 and 255 is
valid, but the TagLength of 0 is valid only for the \s-1MIE\s0 group terminator.
.PP
\fIDataLength\fR
.IX Subsection "DataLength"
.PP
DataLength is an unsigned byte that gives the number of bytes in the data
block.  A value between 0 and 252 gives the data length directly, and
numbers from 253 to 255 are reserved for extended DataLength codes.  Codes
of 255, 254 and 253 indicate that the element contains an additional 2, 4 or
8 byte unsigned integer representing the data length.
.PP
.Vb 4
\&    0\-252      \- length of data block
\&    255 (0xff) \- use DataLength2
\&    254 (0xfe) \- use DataLength4
\&    253 (0xfd) \- use DataLength8
.Ve
.PP
A DataLength of zero is valid for any element except a compressed \s-1MIE\s0 group.
A zero DataLength for an uncompressed \s-1MIE\s0 group indicates that the group
length is unknown.  For other elements, a zero length indicates there is no
associated data.  A terminator element must have a DataLength of 0, 6 or 10,
and may not use an extended DataLength.
.PP
\fITagName\fR
.IX Subsection "TagName"
.PP
The TagName string is 0 to 255 bytes long, and is composed of the \s-1ASCII\s0
characters A\-Z, a\-z, 0\-9 and underline ('_').  Also, a dash ('\-') is used to
separate the language/country code in the TagName of a localized text
string, and a units string (possibly containing other \s-1ASCII\s0 characters) may
be appear in brackets at the end of the TagName.  The TagName string is \s-1NOT\s0
null terminated.  A \s-1MIE\s0 element with a tag string of zero length is reserved
for the group terminator.
.PP
\&\s-1MIE\s0 elements are sorted alphabetically by TagName within each group.
Multiple elements with the same TagName are allowed, even within the same
group.
.PP
TagNames should be meaningful.  Case is significant.  Words should be
lowercase with an uppercase first character, and acronyms should be all
upper case.  The underline (\*(L"_\*(R") is provided to allow separation of two
acronyms or two numbers, but it shouldn't be used unless necessary.  No
separation is necessary between an acronym and a word (eg. \*(L"ISOSetting\*(R").
.PP
All TagNames should start with an uppercase letter.  An exception to this
rule allows tags to begin with a digit (0\-9) if they must come before other
tags in the sort order, or a lowercase letter (a\-z) if they must come after.
For instance, the '0Type' element begins with a digit so it comes before,
and the 'data' element begins with a lowercase letter so that it comes after
meta information tags in the main \*(L"0MIE\*(R" group.
.PP
Tag names for localized text strings have an 6\-character suffix with the
following format:  The first character is a dash ('\-'), followed by a
2\-character lower case \s-1ISO 639\-1\s0 language code, then an underline ('_'), and
ending with a 2\-character upper case \s-1ISO 3166\-1\s0 alpha 2 country code.  (eg.
\&\*(L"\-en_US\*(R", \*(L"\-en_GB\*(R", \*(L"\-de_DE\*(R" or \*(L"\-fr_FR\*(R".  Note that \*(L"\s-1GB\*(R",\s0 and not \*(L"\s-1UK\*(R"\s0 is
the code for Great Britain, although \*(L"\s-1UK\*(R"\s0 should be recognized for
compatibility reasons.)  The suffix is included when sorting the tags
alphabetically, so the default locale (with no tag-name suffix) always comes
first.  If the country is unknown or not applicable, a country code of \*(L"\s-1XX\*(R"\s0
should be used.
.PP
Tags with numerical values may allow units of measurement to be specified.
The units string is stored in brackets at the end of the tag name, and is
composed of zero or more \s-1ASCII\s0 characters in the range 0x21 to 0x7d,
excluding the bracket characters 0x28 and 0x29.  (eg. \*(L"Resolution(/cm)\*(R" or
\&\*(L"SpecificHeat(J/kg.K)\*(R".)  See Image::ExifTool::MIEUnits for details. Unit
strings are not localized, and may not be used in combination with localized
text strings.
.PP
Sets of tags which would require a common prefix should be added in a
separate \s-1MIE\s0 group instead of adding the prefix to all tag names.  For
example, instead of these TagName's:
.PP
.Vb 3
\&    ExternalFlashType
\&    ExternalFlashSerialNumber
\&    ExternalFlashFired
.Ve
.PP
one would instead designate a separate \*(L"ExternalFlash\*(R" \s-1MIE\s0 group to contain
the following elements:
.PP
.Vb 3
\&    Type
\&    SerialNumber
\&    Fired
.Ve
.PP
\fIDataLength2/4/8\fR
.IX Subsection "DataLength2/4/8"
.PP
These extended DataLength fields exist only if DataLength is 255, 254 or
253, and are respectively 2, 4 or 8 byte unsigned integers giving the data
block length.  One of these values must be used if the data block is larger
than 252 bytes, but they may be used if desired for smaller blocks too
(although this may add a few unnecessary bytes to the \s-1MIE\s0 element).
.PP
\fIDataBlock\fR
.IX Subsection "DataBlock"
.PP
The data value for the \s-1MIE\s0 element.  The format of the data is given by the
FormatCode.  For \s-1MIE\s0 group elements, the data includes all contained
elements and the group terminator.
.SS "\s-1MIE\s0 groups"
.IX Subsection "MIE groups"
All \s-1MIE\s0 data elements must be contained within a group.  A group begins with
a \s-1MIE\s0 group element, and ends with a group terminator.  Groups may be nested
in a hierarchy to arbitrary depth.
.PP
A \s-1MIE\s0 group element is identified by a format code of 0x10 (big endian byte
ordering) or 0x18 (little endian).  The group terminator is distinguished by
a zero TagLength (it is the only element allowed to have a zero TagLength),
and has a FormatCode of 0x00.
.PP
The \s-1MIE\s0 group element is permitted to have a zero DataLength only if the
data is uncompressed.  This special value indicates that the group length is
unknown (otherwise the minimum value for DataLength is 4, corresponding the
the minimum group size which includes a terminator of at least 4 bytes). If
DataLength is zero, all elements in the group must be parsed until the group
terminator is found.  If non-zero, DataLength includes the length of all
elements contained within the group, including the group terminator.  Use of
a non-zero DataLength is encouraged because it allows readers quickly skip
over entire \s-1MIE\s0 groups.  For compressed groups DataLength must be non-zero,
and is the length of the compressed group data (which includes the
compressed group terminator).
.PP
\fIGroup Terminator\fR
.IX Subsection "Group Terminator"
.PP
The group terminator has a FormatCode and TagLength of zero.  The terminator
DataLength must be 0, 6 or 10 bytes, and extended DataLength codes may not
be used.  With a zero DataLength, the byte sequence for a terminator is \*(L"7e
00 00 00\*(R" (hex).  With a DataLength of 6 or 10 bytes, the terminator data
block contains information about the length and byte ordering of the
preceding group.  This additional information is recommended for file-level
groups, and is used in multi-document \s-1MIE\s0 files and \s-1MIE\s0 trailers to allow
the file to be scanned backwards from the end.  (This may also allow some
documents to be recovered if part of the file is corrupted.)  The structure
of this optional terminator data block is as follows:
.PP
.Vb 3
\&    4 or 8 bytes  GroupLength (unsigned integer)
\&    1 byte        ByteOrder (0x10 or 0x18, same as MIE group)
\&    1 byte        GroupLengthSize (0x04 or 0x08)
.Ve
.PP
The ByteOrder and GroupLengthSize values give the byte ordering and size of
the GroupLength integer.  The GroupLength value is the total length of the
entire \s-1MIE\s0 group ending with this terminator, including the opening \s-1MIE\s0
group element and the terminator itself.
.PP
\fIFile-level \s-1MIE\s0 groups\fR
.IX Subsection "File-level MIE groups"
.PP
File-level \s-1MIE\s0 groups may \s-1NOT\s0 be compressed.
.PP
All elements in a \s-1MIE\s0 file are contained within a special group with a
TagName of \*(L"0MIE\*(R".  The purpose of the \*(L"\s-1OMIE\*(R"\s0 group is to provide a unique
signature at the start of the file, and to encapsulate information allowing
files to be easily combined.  The \*(L"0MIE\*(R" group must be terminated like any
other group, but it is recommended that the terminator of a file-level group
include the optional data block (defined above) to provide information about
the group length and byte order.
.PP
It is valid to have more than one \*(L"0MIE\*(R" group at the file level, allowing
multiple documents in a single \s-1MIE\s0 file.  Furthermore, the \s-1MIE\s0 structure
enables multi-document files to be generated by simply concatenating two or
more \s-1MIE\s0 files.
.SS "Scanning Backwards through a \s-1MIE\s0 File"
.IX Subsection "Scanning Backwards through a MIE File"
The steps below give an algorithm to quickly locate the last document in a
\&\s-1MIE\s0 file:
.IP "1." 4
Read the last 10 bytes of the file.  (Note that a valid \s-1MIE\s0 file may be as
short as 12 bytes long, but a file this length contains only an an empty \s-1MIE\s0
group.)
.IP "2." 4
If the last byte of the file is zero, then it is not possible to scan
backward through the file, so the file must be scanned from the beginning.
Otherwise, proceed to the next step.
.IP "3." 4
If the last byte is 4 or 8, the terminator contains information about the
byte ordering and length of the group.  Otherwise, stop here because this
isn't a valid \s-1MIE\s0 file.
.IP "4." 4
The next-to-last byte must be either 0x10 indicating big-endian byte
ordering or 0x18 for little-endian ordering, otherwise this isn't a valid
\&\s-1MIE\s0 file.
.IP "5." 4
The value of the preceding 4 or 8 bytes gives the length of the complete
file-level \s-1MIE\s0 group (GroupLength).  This length includes both the leading
\&\s-1MIE\s0 group element and the terminator element itself.  The value is an
unsigned integer with a byte length given in step 3), and a byte order from
step 4).  From the current file position (at the end of the data read in
step 1), seek backward by this number of bytes to find the start of the \s-1MIE\s0
group element for this document.
.PP
This algorithm may be repeated again beginning at this point in the file to
locate the next-to-last document, etc.
.PP
The table below lists all 5 valid patterns for the last 14 bytes of a
file-level \s-1MIE\s0 group, with all numbers in hex.  The comments indicate the
length and byte ordering of GroupLength (xx) if available:
.PP
.Vb 5
\&  ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 7e 00 00 00  \- (no GroupLength)
\&  ?? ?? ?? ?? 7e 00 00 06 xx xx xx xx 10 04  \- 4 bytes, big endian
\&  ?? ?? ?? ?? 7e 00 00 06 xx xx xx xx 18 04  \- 4 bytes, little endian
\&  7e 00 00 0a xx xx xx xx xx xx xx xx 10 08  \- 8 bytes, big endian
\&  7e 00 00 0a xx xx xx xx xx xx xx xx 18 08  \- 8 bytes, little endian
.Ve
.SS "Trailer Signature"
.IX Subsection "Trailer Signature"
The \s-1MIE\s0 format may be used for trailer information appended to other types
of files.  When this is done, a signature must appear at the end of the main
\&\s-1MIE\s0 group to uniquely identify the \s-1MIE\s0 format trailer.  To achieve this, a
\&\*(L"zmie\*(R" trailer signature is written as the last element in the main \*(L"0MIE\*(R"
group.  This element has a FormatCode of 0, a TagLength of 4, a DataLength
of 0, and a TagName of \*(L"zmie\*(R".  With this signature, the hex byte sequence
\&\*(L"7e 00 04 00 7a 6d 69 65\*(R" appears immediately before the final group
terminator, and the last 22 bytes of the trailer correspond to one of the
following 4 patterns (where the trailer length is given by \*(L"xx\*(R", as above):
.PP
.Vb 4
\&  ?? ?? ?? ?? 7e 00 04 00 7a 6d 69 65 7e 00 00 06 xx xx xx xx 10 04
\&  ?? ?? ?? ?? 7e 00 04 00 7a 6d 69 65 7e 00 00 06 xx xx xx xx 18 04
\&  7e 00 04 00 7a 6d 69 65 7e 00 00 0a xx xx xx xx xx xx xx xx 10 08
\&  7e 00 04 00 7a 6d 69 65 7e 00 00 0a xx xx xx xx xx xx xx xx 18 08
.Ve
.PP
Note that the zero-DataLength terminator may not be used here because the
trailer length must be known for seeking backwards from the end of the file.
.PP
Multiple trailers may be appended to the same file using this technique.
.SS "\s-1MIE\s0 Data Values"
.IX Subsection "MIE Data Values"
\&\s-1MIE\s0 data values for a given tag are usually not restricted to a specific
FormatCode.  Any value may be represented in any appropriate format,
including numbers represented in string (\s-1ASCII\s0 or \s-1UTF\s0) form.
.PP
It is preferred that closely related values with the same format are written
to a single tag instead of using multiple tags.  This improves localization
of like values and decreases \s-1MIE\s0 element overhead.  For instance, instead of
separate ImageWidth and ImageHeight tags, a single ImageSize tag is defined.
.PP
Tags which may take on a discrete set of values should have meaningful
values if possible.  This improves the extensibility of the format and
allows a more reasonable interpretation of unrecognized values.
.PP
\fINumerical Representation\fR
.IX Subsection "Numerical Representation"
.PP
Integer and floating point numbers may be represented in binary or string
form.  In string form, integers are a series of digits with an optional
leading sign (eg. \*(L"[+|\-]DDDDDD\*(R"), and multiple values are separated by a
single space character (eg. \*(L"23 128 \-32\*(R").  Floating point numbers are
similar but may also contain a decimal point and/or a signed exponent with a
leading 'e' character (eg. \*(L"[+|\-]DD[.DDDDDD][e(+|\-)EEE]\*(R").  The string \*(L"inf\*(R"
is used to represent infinity.  One advantage of numerical strings is that
they can have an arbitrarily high precision because the possible number of
significant digits is virtually unlimited.
.PP
Note that numerical values may have associated units of measurement which
are specified in the \*(L"TagName\*(R" string.
.PP
\fIDate/Time Format\fR
.IX Subsection "Date/Time Format"
.PP
All \s-1MIE\s0 dates are strings in the form \*(L"YYYY:mm:dd \s-1HH:MM:SS\s0.ss+HH:MM\*(R".  The
fractional seconds (\*(L".ss\*(R") are optional, and if included may contain any
number of significant digits (unlike all other fields which are a fixed
number of digits and must be padded with leading zeros if necessary).  The
timezone (\*(L"+HH:MM\*(R" or \*(L"\-HH:MM\*(R") is recommended but not required.  If not
given, the local system timezone is assumed.
.SS "\s-1MIME\s0 Type"
.IX Subsection "MIME Type"
The basic \s-1MIME\s0 type for a \s-1MIE\s0 file is \*(L"application/x\-mie\*(R", however the
specific \s-1MIME\s0 type depends on the type of subfile, and is obtained by adding
\&\*(L"x\-mie\-\*(R" to the \s-1MIME\s0 type of the subfile.  For example, with a subfile of
type \*(L"image/jpeg\*(R", the \s-1MIE\s0 file \s-1MIME\s0 type is \*(L"image/x\-mie\-jpeg\*(R".  But note
that the \*(L"x\-\*(R" is not duplicated if the subfile \s-1MIME\s0 type already starts with
\&\*(L"x\-\*(R".  So a subfile with \s-1MIME\s0 type \*(L"image/x\-raw\*(R" is contained within a \s-1MIE\s0
file of type \*(L"image/x\-mie\-raw\*(R", not \*(L"image/x\-mie\-x\-raw\*(R".  In the case of
multiple documents in a \s-1MIE\s0 file, the \s-1MIME\s0 type is taken from the first
document.  Regardless of the subfile type, all MIE-format files should have
a filename extension of \*(L".MIE\*(R".
.SS "Levels of Support"
.IX Subsection "Levels of Support"
Basic \s-1MIE\s0 reader/writer applications may choose not to provide support for
some advanced features of the \s-1MIE\s0 format.  Features which may not be
supported by all software are:
.IP "Compression" 4
.IX Item "Compression"
Software not supporting compression must ignore compressed elements and
groups, but should be able to process the remaining information.
.IP "Large data lengths" 4
.IX Item "Large data lengths"
Some software may limit the maximum size of a \s-1MIE\s0 group or element.
Historically, a limit of 2GB may be imposed by some systems.  However,
8\-byte data lengths should be supported by all applications provided the
value doesn't exceed the system limit.  (eg. For systems with a 2GB limit,
8\-byte data lengths should be supported if the upper 17 bits are all zero.)
If a data length above the system limit is encountered, it may be necessary
for the application to stop processing if it can not seek to the next
element in the file.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This section gives examples for working with \s-1MIE\s0 information using ExifTool.
.SS "Encapsulating Information with Data in a \s-1MIE\s0 File"
.IX Subsection "Encapsulating Information with Data in a MIE File"
The following command encapsulates any file recognized by ExifTool inside a
\&\s-1MIE\s0 file, and initializes \s-1MIE\s0 tags from information within the file:
.PP
.Vb 3
\&    exiftool \-o new.mie \-tagsfromfile FILE \*(Aq\-mie:all<all\*(Aq \e
\&        \*(Aq\-subfilename<filename\*(Aq \*(Aq\-subfiletype<filetype\*(Aq \e
\&        \*(Aq\-subfilemimetype<mimetype\*(Aq \*(Aq\-subfiledata<=FILE\*(Aq
.Ve
.PP
where \f(CW\*(C`FILE\*(C'\fR is the name of the file.
.PP
For unrecognized files, this command may be used:
.PP
.Vb 2
\&    exiftool \-o new.mie \-subfilename=FILE \-subfiletype=TYPE \e
\&        \-subfilemimetype=MIME \*(Aq\-subfiledata<=FILE\*(Aq
.Ve
.PP
where \f(CW\*(C`TYPE\*(C'\fR and \f(CW\*(C`MIME\*(C'\fR represent the source file type and \s-1MIME\s0 type
respectively.
.SS "Adding a \s-1MIE\s0 Trailer to a File"
.IX Subsection "Adding a MIE Trailer to a File"
The \s-1MIE\s0 format may also be used to store information in a trailer appended
to another type of file.  Beware that trailers may not be compatible with
all file formats, but \s-1JPEG\s0 and \s-1TIFF\s0 are two formats where additional trailer
information doesn't create any problems for normal parsing of the file.
Also note that this technique has the disadvantage that trailer information
is commonly lost if the file is subsequently edited by other software.
.PP
Creating a \s-1MIE\s0 trailer with ExifTool is a two-step process since ExifTool
can't currently be used to add a \s-1MIE\s0 trailer directly.  The example below
illustrates the steps for adding a \s-1MIE\s0 trailer with a small preview image
(\f(CW\*(C`small.jpg\*(C'\fR) to a destination \s-1JPEG\s0 image (\f(CW\*(C`dst.jpg\*(C'\fR).
.PP
Step 1) Create a \s-1MIE\s0 file with a TrailerSignature containing the desired
information:
.PP
.Vb 3
\&    exiftool \-o new.mie \-trailersignature=1 \-tagsfromfile small.jpg \e
\&        \*(Aq\-previewimagetype<filetype\*(Aq \*(Aq\-previewimagesize<imagesize\*(Aq \e
\&        \*(Aq\-previewimagename<filename\*(Aq \*(Aq\-previewimage<=small.jpg\*(Aq
.Ve
.PP
Step 2) Append the \s-1MIE\s0 information to another file.  In Unix, this can be
done with the 'cat' command:
.PP
.Vb 1
\&    cat new.mie >> dst.jpg
.Ve
.PP
Once added, ExifTool may be used to edit or delete a \s-1MIE\s0 trailer in a \s-1JPEG\s0
or \s-1TIFF\s0 image.
.SS "Multiple \s-1MIE\s0 Documents in a Single File"
.IX Subsection "Multiple MIE Documents in a Single File"
The \s-1MIE\s0 specification allows multiple \s-1MIE\s0 documents (or trailers) to exist
in a single file.  A file like this may be created by simply concatenating
\&\s-1MIE\s0 documents.  ExifTool may be used to access information in a specific
document by adding a copy number to the \s-1MIE\s0 group name.  For example:
.PP
.Vb 2
\&    # write the Author tag in the second MIE document
\&    exiftool \-mie2:author=phil test.mie
\&
\&    # delete the first MIE document from a file
\&    exiftool \-mie1:all= test.mie
.Ve
.SS "Units of Measurement"
.IX Subsection "Units of Measurement"
Some \s-1MIE\s0 tags allow values to be specified in different units of
measurement.  In the \s-1MIE\s0 file format these units are combined with the tag
name, but when using ExifTool they are specified in brackets after the
value:
.PP
.Vb 1
\&    exiftool \-mie:gpsaltitude=\*(Aq7500(ft)\*(Aq test.mie
.Ve
.PP
If no units are provided, the default units are written.
.SS "Localized Text"
.IX Subsection "Localized Text"
Localized text values are accessed by adding a language/country code to the
tag name.  For example:
.PP
.Vb 1
\&    exiftool \-comment\-en_us=\*(Aqthis is a comment\*(Aq test.mie
.Ve
.SH "REVISIONS"
.IX Header "REVISIONS"
.Vb 10
\&  2010\-04\-05 \- Fixed "Format Size" Note 7 to give the correct number of bits
\&               in the example rational value
\&  2007\-01\-21 \- Specified LF character (0x0a) for text newline sequence
\&  2007\-01\-19 \- Specified ISO 8859\-1 character set for extended ASCII codes
\&  2007\-01\-01 \- Improved wording of Step 5 for scanning backwards in MIE file
\&  2006\-12\-30 \- Added EXAMPLES section and note about UTF BOM
\&  2006\-12\-20 \- MIE 1.1:  Changed meaning of TypeModifier bit (0x08) for
\&               unknown data (FormatType 0x00), and documented byte swapping
\&  2006\-12\-14 \- MIE 1.0:  Added Data Values and Numerical Representations
\&               sections, and added ability to specify units in tag names
\&  2006\-11\-09 \- Added Levels of Support section
\&  2006\-11\-03 \- Added Trailer Signature
\&  2005\-11\-18 \- Original specification created
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright 2003\-2016, Phil Harvey (phil at owl.phy.queensu.ca)
.PP
This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.  The \s-1MIE\s0 format itself is also
copyright Phil Harvey, and is covered by the same free-use license.
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "<http://owl.phy.queensu.ca/~phil/exiftool/MIE1.1\-20070121.pdf>" 4
.IX Item "<http://owl.phy.queensu.ca/~phil/exiftool/MIE1.1-20070121.pdf>"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"\s-1MIE\s0 Tags\*(R" in Image::ExifTool::TagNames, Image::ExifTool::MIEUnits,
\&\fIImage::ExifTool\fR\|(3pm)
